/**
 * @fileoverview IndexedDB schema for offline operation using Dexie.js
 * Provides local storage for products, categories, and pending operations
 * 
 * @module lib/offlineDb
 */

import Dexie, { type Table } from 'dexie';

// ============================================================================
// CACHED DATA TYPES (from sync/pull)
// ============================================================================

export interface OfflineProduct {
    id: number;
    name: string;
    price: number;
    categoryId: number;
    categoryName: string;
    isActive: boolean;
    productType: string;
    modifierGroups: OfflineModifierGroup[];
}

export interface OfflineModifierGroup {
    id: number;
    name: string;
    minSelection: number;
    maxSelection: number;
    options: OfflineModifierOption[];
}

export interface OfflineModifierOption {
    id: number;
    name: string;
    price: number;
}

export interface OfflineCategory {
    id: number;
    name: string;
}

export interface OfflinePrinterRouting {
    categoryId: number;
    printerId: number;
    printerName: string;
    connectionType: string;
    ipAddress: string | null;
    windowsName: string | null;
}

// ============================================================================
// PENDING OPERATION TYPES (to be synced)
// ============================================================================

export interface PendingOrderItem {
    productId: number;
    quantity: number;
    notes?: string;
    modifiers?: { id: number; price: number }[];
    removedIngredientIds?: number[];
}

export interface PendingOrder {
    localId?: number;           // Auto-generated by IndexedDB
    tempId: string;             // Client-generated unique ID
    items: PendingOrderItem[];
    channel: 'POS' | 'DELIVERY_APP' | 'WAITER_APP' | 'QR_MENU';
    tableId?: number;
    clientId?: number;
    createdAt: Date;
    shiftId?: number;
    status: 'pending' | 'syncing' | 'synced' | 'error';
    errorMessage?: string;
}

export interface PendingPayment {
    localId?: number;           // Auto-generated by IndexedDB
    tempOrderId: string;        // Reference to PendingOrder.tempId
    method: 'CASH' | 'CARD' | 'TRANSFER' | 'WALLET' | 'OTHER';
    amount: number;
    createdAt: Date;
    status: 'pending' | 'syncing' | 'synced' | 'error';
    errorMessage?: string;
}

// ============================================================================
// SYNC METADATA
// ============================================================================

export interface SyncStatus {
    key: string;                // 'lastSync', 'syncToken', etc.
    value: string;
    updatedAt: Date;
}

// ============================================================================
// DATABASE CLASS
// ============================================================================

export class OfflineDatabase extends Dexie {
    // Cached data tables (read-only, refreshed from server)
    products!: Table<OfflineProduct, number>;
    categories!: Table<OfflineCategory, number>;
    printerRouting!: Table<OfflinePrinterRouting, number>;

    // Pending operations tables (write queue)
    pendingOrders!: Table<PendingOrder, number>;
    pendingPayments!: Table<PendingPayment, number>;

    // Metadata
    syncStatus!: Table<SyncStatus, string>;

    constructor() {
        super('PentiumPOS');
        
        this.version(1).stores({
            // Cached data - indexed by id for lookups
            products: 'id, categoryId, name',
            categories: 'id, name',
            printerRouting: 'categoryId, printerId',
            
            // Pending operations - auto-increment localId
            pendingOrders: '++localId, tempId, status',
            pendingPayments: '++localId, tempOrderId, status',
            
            // Metadata - key is primary
            syncStatus: 'key'
        });
    }

    // =========================================================================
    // HELPER METHODS
    // =========================================================================

    /**
     * Clear all cached data (before refresh)
     */
    async clearCachedData() {
        await Promise.all([
            this.products.clear(),
            this.categories.clear(),
            this.printerRouting.clear()
        ]);
    }

    /**
     * Store sync data from server
     */
    async storeSyncData(data: {
        products: OfflineProduct[];
        categories: OfflineCategory[];
        printerRouting: OfflinePrinterRouting[];
        serverTime: string;
        syncToken: string;
    }) {
        await this.transaction('rw', 
            [this.products, this.categories, this.printerRouting, this.syncStatus], 
            async () => {
                // Clear existing cached data
                await this.clearCachedData();
                
                // Bulk insert new data
                await this.products.bulkPut(data.products);
                await this.categories.bulkPut(data.categories);
                await this.printerRouting.bulkPut(data.printerRouting);
                
                // Update sync metadata
                await this.syncStatus.put({
                    key: 'lastSync',
                    value: data.serverTime,
                    updatedAt: new Date()
                });
                await this.syncStatus.put({
                    key: 'syncToken',
                    value: data.syncToken,
                    updatedAt: new Date()
                });
            }
        );
    }

    /**
     * Get all pending orders that need to be synced
     */
    async getPendingOrders(): Promise<PendingOrder[]> {
        return this.pendingOrders
            .where('status')
            .equals('pending')
            .toArray();
    }

    /**
     * Get all pending payments that need to be synced
     */
    async getPendingPayments(): Promise<PendingPayment[]> {
        return this.pendingPayments
            .where('status')
            .equals('pending')
            .toArray();
    }

    /**
     * Count pending operations
     */
    async getPendingCount(): Promise<number> {
        const [orders, payments] = await Promise.all([
            this.pendingOrders.where('status').equals('pending').count(),
            this.pendingPayments.where('status').equals('pending').count()
        ]);
        return orders + payments;
    }

    /**
     * Mark orders as synced
     */
    async markOrdersSynced(tempIds: string[]) {
        await this.pendingOrders
            .where('tempId')
            .anyOf(tempIds)
            .modify({ status: 'synced' });
    }

    /**
     * Mark order as error
     */
    async markOrderError(tempId: string, errorMessage: string) {
        await this.pendingOrders
            .where('tempId')
            .equals(tempId)
            .modify({ status: 'error', errorMessage });
    }

    /**
     * Generate a unique temporary ID
     */
    generateTempId(): string {
        return `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
}

// Singleton instance
export const offlineDb = new OfflineDatabase();
